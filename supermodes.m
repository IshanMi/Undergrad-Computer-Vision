clear all;clc
 
%% Load propagation constant of single mode isolated step-index circular waveguide (at 532nm)
load('singlewg_lambda532_ZEP.mat');
 
%% Declarations of physical constants
nm = 1e-9;
um = 1e-6;
 
n1 = 2.4;
n2 = 1.5;
 
eps0 = 8.85418782*10^(-12);
eps1 = eps0*n1^2;
eps2 = eps0*n2^2;
mu0 = 4*pi*10^(-7);
 
n = 1;
 
c = 299792458;
 
 
%% Parameters
H = 600*nm;
wl_vec = [532]*nm;
 
%% Periodic boundary condition
U = 250*nm;
 
%% Variables depending on the radius
a_vec = [50:1:125]*nm; % Waveguide radius
beta_vec = zeros(size(a_vec));
Mf = 101;
neff_supermode = zeros(Mf,Mf,length(a_vec));
 
%% test
radii_exp=radii;
neff=neff_singlewg;
 
for wlind = 1 : length(wl_vec)
    for aind = 1 : length(a_vec)
        wl = wl_vec(wlind);
        a = a_vec(aind);
        display(strcat('Running a =',num2str(a/nm)));
         
        inda = min(find(radii_exp>=a));
        if isempty(find(radii_exp>=a))
           inda = length(radii_exp); 
        end
         
        k0 = 2*pi/wl;
        w0 = c*k0;
        hmax = k0*sqrt(n1^2 - n2^2);
         
        beta = k0*neff(inda);
        beta_vec(aind) = beta;
         
        h = sqrt(k0^2*n1^2-beta^2);
        q = sqrt(-k0^2*n2^2+beta^2);
        M = 8;
         
        %% Constant coefficients
        ConstA = 1;
         
        ConstB = sqrt(-1).*beta.*mu0.^(-1).*n.*(a.^(-2).*h.^(-2)+a.^(-2).*q.^(-2)) ...
            .*w0.^(-1).*((1/2).*a.^(-1).*h.^(-1).*besselj(n,a.*h).^(-1).*( ...
            besselj((-1)+n,a.*h)+(-1).*besselj(1+n,a.*h))+(1/2).*a.^(-1).*q.^( ...
            -1).*besselk(n,a.*q).^(-1).*((-1).*besselk((-1)+n,a.*q)+(-1).* ...
            besselk(1+n,a.*q))).^(-1);
         
        ConstC = besselj(n,a.*h).*besselk(n,a.*q).^(-1);
         
        ConstD = sqrt(-1).*beta.*mu0.^(-1).*n.*(a.^(-2).*h.^(-2)+a.^(-2).*q.^(-2)) ...
            .*w0.^(-1).*besselj(n,a.*h).*besselk(n,a.*q).^(-1).*((1/2).*a.^( ...
            -1).*h.^(-1).*besselj(n,a.*h).^(-1).*(besselj((-1)+n,a.*h)+(-1).* ...
            besselj(1+n,a.*h))+(1/2).*a.^(-1).*q.^(-1).*besselk(n,a.*q).^(-1) ...
            .*((-1).*besselk((-1)+n,a.*q)+(-1).*besselk(1+n,a.*q))).^(-1);
         
        %% Discretization of space
        xvec = linspace(-15*a,15*a,1000);
        yvec = linspace(-15*a,15*a,1000);
        x1 = zeros(length(xvec),length(yvec));
        y1 = zeros(length(xvec),length(yvec));
         
        for i = 1 : length(xvec)
            x1(:,i)=xvec(i);
        end
         
        for j = 1 : length(yvec)
            y1(j,:)=yvec(length(yvec)-j+1);
        end
         
        %% Electric field 1
        Ex1= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.*mu0.*n.* ...
            w0.*(x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+( ...
            -1/2).*ConstC.*q.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1) ...
            .*ConstB.*mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*cos((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))))+(-1).*(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*( ...
            x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+(1/2).* ...
            beta.^(-1).*ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(x1.^2+y1.^2) ...
            .^(1/2))+besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+ ...
            y1.^2).^(1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).* ...
            ConstA.*n.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+y1.^2).^( ...
            1/2))+(-1/2).*beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*( ...
            x1.^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))) ...
            .*(((x1.^2+y1.^2).^(1/2))<=(a))).*sin((((x1)==(0)).*((1/2).* ...
            pi.*((y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*( ...
            atan(x1.^(-1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan( ...
            x1.^(-1).*y1)).*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).* ...
            y1)).*((x1)<(0)))));
         
        Ey1= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*(x1.^2+y1.^2).^( ...
            -1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+(1/2).*beta.^(-1).* ...
            ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*ConstA.*n.* ...
            (x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+y1.^2).^(1/2))+(-1/2).* ...
            beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*cos((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))))+(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.* ...
            mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^( ...
            1/2))+(-1/2).*ConstC.*q.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1) ...
            .*ConstB.*mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*sin((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))));
         
        Ez1= ConstC.*besselk(n,q.*(x1.^2+y1.^2).^(1/2)).*(((x1.^2+y1.^2) ...
            .^(1/2))>=(a))+ConstA.*besselj(n,h.*(x1.^2+y1.^2).^(1/2)).*(( ...
            (x1.^2+y1.^2).^(1/2))<=(a));
         
         
        %% Normalization of ConstA
        L_int = conj(Ex1).*Ex1+conj(Ey1).*Ey1+conj(Ez1).*Ez1;
        LL = trapz(yvec,trapz(xvec,L_int));
        ConstA = 1/sqrt(LL);
        ConstB = ConstB*ConstA;
        ConstC = ConstC*ConstA;
        ConstD = ConstD*ConstA;
        display('Normalization');
         
        %% Electric field 1 & 2
        Ex1= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.*mu0.*n.* ...
            w0.*(x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+( ...
            -1/2).*ConstC.*q.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1) ...
            .*ConstB.*mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*cos((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))))+(-1).*(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*( ...
            x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+(1/2).* ...
            beta.^(-1).*ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(x1.^2+y1.^2) ...
            .^(1/2))+besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+ ...
            y1.^2).^(1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).* ...
            ConstA.*n.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+y1.^2).^( ...
            1/2))+(-1/2).*beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*( ...
            x1.^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))) ...
            .*(((x1.^2+y1.^2).^(1/2))<=(a))).*sin((((x1)==(0)).*((1/2).* ...
            pi.*((y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*( ...
            atan(x1.^(-1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan( ...
            x1.^(-1).*y1)).*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).* ...
            y1)).*((x1)<(0)))));
         
        Ey1= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*(x1.^2+y1.^2).^( ...
            -1/2).*besselk(n,q.*(x1.^2+y1.^2).^(1/2))+(1/2).*beta.^(-1).* ...
            ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*ConstA.*n.* ...
            (x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+y1.^2).^(1/2))+(-1/2).* ...
            beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*cos((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))))+(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.* ...
            mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselk(n,q.*(x1.^2+y1.^2).^( ...
            1/2))+(-1/2).*ConstC.*q.*(besselk((-1)+n,q.*(x1.^2+y1.^2).^(1/2))+ ...
            besselk(1+n,q.*(x1.^2+y1.^2).^(1/2)))).*(((x1.^2+y1.^2).^( ...
            1/2))>=(a))+(sqrt(-1)*(-1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1) ...
            .*ConstB.*mu0.*n.*w0.*(x1.^2+y1.^2).^(-1/2).*besselj(n,h.*(x1.^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(x1.^2+y1.^2) ...
            .^(1/2))+(-1).*besselj(1+n,h.*(x1.^2+y1.^2).^(1/2)))).*((( ...
            x1.^2+y1.^2).^(1/2))<=(a))).*sin((((x1)==(0)).*((1/2).*pi.*(( ...
            y1)>(0))+(3/2).*pi.*((y1)<(0)))+(~((x1)==(0))).*(atan(x1.^( ...
            -1).*y1).*(((x1)>(0))&((y1)>=(0)))+(2.*pi+atan(x1.^(-1).*y1)) ...
            .*(((x1)>(0))&((y1)<(0)))+(pi+atan(x1.^(-1).*y1)).*((x1) ...
            <(0)))));
         
        Ez1= ConstC.*besselk(n,q.*(x1.^2+y1.^2).^(1/2)).*(((x1.^2+y1.^2) ...
            .^(1/2))>=(a))+ConstA.*besselj(n,h.*(x1.^2+y1.^2).^(1/2)).*(( ...
            (x1.^2+y1.^2).^(1/2))<=(a));
         
         
        % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
         
        Ex2= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.*mu0.*n.* ...
            w0.*(((-1).*U+x1).^2+y1.^2).^(-1/2).*besselk(n,q.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+(-1/2).*ConstC.*q.*(besselk((-1)+n,q.*(((-1).* ...
            U+x1).^2+y1.^2).^(1/2))+besselk(1+n,q.*(((-1).*U+x1).^2+y1.^2).^( ...
            1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))>=(a))+(sqrt(-1)*( ...
            -1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1).*ConstB.*mu0.*n.*w0.*(( ...
            (-1).*U+x1).^2+y1.^2).^(-1/2).*besselj(n,h.*(((-1).*U+x1).^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(((-1).*U+x1).^2+y1.^2).^( ...
            1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))<=(a))).*cos((((x1) ...
            ==(U)).*((1/2).*pi.*((y1)>(0))+(3/2).*pi.*((y1)<(0)))+( ...
            ~((x1)==(U))).*(atan(((-1).*U+x1).^(-1).*y1).*(((x1)>(U))&(( ...
            y1)>=(0)))+(2.*pi+atan(((-1).*U+x1).^(-1).*y1)).*(((x1)>(U)) ...
            &((y1)<(0)))+(pi+atan(((-1).*U+x1).^(-1).*y1)).*((x1)<(U))))) ...
            +(-1).*(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*(((-1).*U+ ...
            x1).^2+y1.^2).^(-1/2).*besselk(n,q.*(((-1).*U+x1).^2+y1.^2).^(1/2) ...
            )+(1/2).*beta.^(-1).*ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(((-1) ...
            .*U+x1).^2+y1.^2).^(1/2))+besselk(1+n,q.*(((-1).*U+x1).^2+y1.^2) ...
            .^(1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))>=(a))+(sqrt(-1) ...
            *(-1)).*beta.*h.^(-2).*(sqrt(-1).*ConstA.*n.*(((-1).*U+x1).^2+ ...
            y1.^2).^(-1/2).*besselj(n,h.*(((-1).*U+x1).^2+y1.^2).^(1/2))+( ...
            -1/2).*beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*(((-1).* ...
            U+x1).^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(((-1).*U+x1).^2+ ...
            y1.^2).^(1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))<=(a))).* ...
            sin((((x1)==(U)).*((1/2).*pi.*((y1)>(0))+(3/2).*pi.*(( ...
            y1)<(0)))+(~((x1)==(U))).*(atan(((-1).*U+x1).^(-1).*y1).*((( ...
            x1)>(U))&((y1)>=(0)))+(2.*pi+atan(((-1).*U+x1).^(-1).*y1)).*( ...
            ((x1)>(U))&((y1)<(0)))+(pi+atan(((-1).*U+x1).^(-1).*y1)).*(( ...
            x1)<(U)))));
         
        Ey2= (sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*ConstC.*n.*(((-1).*U+x1).^2+ ...
            y1.^2).^(-1/2).*besselk(n,q.*(((-1).*U+x1).^2+y1.^2).^(1/2))+(1/2) ...
            .*beta.^(-1).*ConstD.*mu0.*q.*w0.*(besselk((-1)+n,q.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+besselk(1+n,q.*(((-1).*U+x1).^2+y1.^2).^(1/2))) ...
            ).*(((((-1).*U+x1).^2+y1.^2).^(1/2))>=(a))+(sqrt(-1)*(-1)).* ...
            beta.*h.^(-2).*(sqrt(-1).*ConstA.*n.*(((-1).*U+x1).^2+y1.^2).^( ...
            -1/2).*besselj(n,h.*(((-1).*U+x1).^2+y1.^2).^(1/2))+(-1/2).* ...
            beta.^(-1).*ConstB.*h.*mu0.*w0.*(besselj((-1)+n,h.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(((-1).*U+x1).^2+y1.^2).^( ...
            1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))<=(a))).*cos((((x1) ...
            ==(U)).*((1/2).*pi.*((y1)>(0))+(3/2).*pi.*((y1)<(0)))+( ...
            ~((x1)==(U))).*(atan(((-1).*U+x1).^(-1).*y1).*(((x1)>(U))&(( ...
            y1)>=(0)))+(2.*pi+atan(((-1).*U+x1).^(-1).*y1)).*(((x1)>(U)) ...
            &((y1)<(0)))+(pi+atan(((-1).*U+x1).^(-1).*y1)).*((x1)<(U))))) ...
            +(sqrt(-1).*beta.*q.^(-2).*(sqrt(-1).*beta.^(-1).*ConstD.*mu0.*n.* ...
            w0.*(((-1).*U+x1).^2+y1.^2).^(-1/2).*besselk(n,q.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+(-1/2).*ConstC.*q.*(besselk((-1)+n,q.*(((-1).* ...
            U+x1).^2+y1.^2).^(1/2))+besselk(1+n,q.*(((-1).*U+x1).^2+y1.^2).^( ...
            1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))>=(a))+(sqrt(-1)*( ...
            -1)).*beta.*h.^(-2).*(sqrt(-1).*beta.^(-1).*ConstB.*mu0.*n.*w0.*(( ...
            (-1).*U+x1).^2+y1.^2).^(-1/2).*besselj(n,h.*(((-1).*U+x1).^2+ ...
            y1.^2).^(1/2))+(1/2).*ConstA.*h.*(besselj((-1)+n,h.*(((-1).*U+x1) ...
            .^2+y1.^2).^(1/2))+(-1).*besselj(1+n,h.*(((-1).*U+x1).^2+y1.^2).^( ...
            1/2)))).*(((((-1).*U+x1).^2+y1.^2).^(1/2))<=(a))).*sin((((x1) ...
            ==(U)).*((1/2).*pi.*((y1)>(0))+(3/2).*pi.*((y1)<(0)))+( ...
            ~((x1)==(U))).*(atan(((-1).*U+x1).^(-1).*y1).*(((x1)>(U))&(( ...
            y1)>=(0)))+(2.*pi+atan(((-1).*U+x1).^(-1).*y1)).*(((x1)>(U)) ...
            &((y1)<(0)))+(pi+atan(((-1).*U+x1).^(-1).*y1)).*((x1)<(U))))) ...
            ;
         
        Ez2= ConstC.*besselk(n,q.*(((-1).*U+x1).^2+y1.^2).^(1/2)).*((((( ...
            -1).*U+x1).^2+y1.^2).^(1/2))>=(a))+ConstA.*besselj(n,h.*(((-1).*U+ ...
            x1).^2+y1.^2).^(1/2)).*(((((-1).*U+x1).^2+y1.^2).^(1/2))<=(a) ...
            );
         
        %% Defining index modulation
        centers = -M*U:U:M*U;
        index = zeros(length(xvec),length(yvec));
        for k = 1:length(centers)
            for l = 1:length(centers)
                ki = centers(k);
                li = centers(l);
                index = index + ((x1-ki).^2+(y1-li).^2<a^2).*(n1^2-n2^2);
            end
        end
        index0 = index - ((x1).^2+(y1).^2<a^2).*(n1^2-n2^2);
         
        %% Overlapping integrals
        I_int = conj(Ex1).*Ex2+conj(Ey1).*Ey2+conj(Ez1).*Ez2;
        J_int = (conj(Ex1).*Ex2+conj(Ey1).*Ey2+conj(Ez1).*Ez2).*index0;
        K_int = (conj(Ex1).*Ex1+conj(Ey1).*Ey1+conj(Ez1).*Ez1).*index0;
         
        II = trapz(yvec,trapz(xvec,I_int));
        JJ = (w0/c)^2*trapz(yvec,trapz(xvec,J_int));
        KK = (w0/c)^2*trapz(yvec,trapz(xvec,K_int));
         
        if(abs(real(II))>100*abs(imag(II)))
            II = real(II);
        end
         
        if(abs(real(JJ))>100*abs(imag(JJ)))
            JJ = real(JJ);
        end
         
        if(abs(real(KK))>100*abs(imag(KK)))
            KK = real(KK);
        end
         
        %% Effective supermode index
        supermodesx = 1:Mf;
        supermodesy = 1:Mf;
         
        for i = 1 : Mf
            for j = 1: Mf
                neff_supermode(i,j,aind) = 1/k0*sqrt(beta^2+...
                    (KK+2*JJ*(cos(supermodesx(i)*pi/(Mf+1))+cos(supermodesy(j)*pi/(Mf+1)))./...
                    (1+2*II*(cos(supermodesx(i)*pi/(Mf+1))+cos(supermodesy(j)*pi/(Mf+1))))));
            end
        end
         
        temp = squeeze(min(min(neff_supermode(:,:,aind))));
        minneff(aind) = temp(1);
        temp = squeeze(max(max(neff_supermode(:,:,aind))));
        maxneff(aind) = temp(1);
        temp = squeeze(mean(mean(neff_supermode(:,:,aind))));
        avgneff(aind) = temp(1);
         
        display(strcat('Radius',num2str(a/nm)));
        display(beta/k0);
        display('New effective indices of supermodes');
        display(minneff(aind));
        display(maxneff(aind));
        display(avgneff(aind))
         
        II_vec(aind) = II;
        JJ_vec(aind) = JJ;
        KK_vec(aind) = KK;
         
    end
end
 
% %% Plotting 3D map
% % Fundamental supermode coefficients
% for n = 1 : Mf
%     for m = 1 : Mf
%         C(n,m) = sin(n*pi/(Mf+1))*sin(m*pi/(Mf+1));
%     end
% end
% 
% totalEx = zeros(length(xvec),length(yvec));
% totalEy = zeros(length(xvec),length(yvec));
% totalEz = zeros(length(xvec),length(yvec));
% for n = -10 : 1 : 10
%     for m = -10 : 1 : 10
%         for i = 1 : length(xvec)
%             for j = 1 : length(yvec)
%                 shiftU = floor(U/(xvec(2)-xvec(1)));
%                 if(i-n*shiftU>1)&&(i-n*shiftU<length(xvec))
%                     if(j-m*shiftU>1)&&(j-m*shiftU<length(xvec))
%                         totalEx(i,j) = totalEx(i,j)+ C(n+floor(Mf/2),m+floor(Mf/2))*Ex1(i-n*shiftU,j-m*shiftU);
%                         totalEy(i,j) = totalEy(i,j)+ C(n+floor(Mf/2),m+floor(Mf/2))*Ey1(i-n*shiftU,j-m*shiftU);
%                         totalEz(i,j) = totalEz(i,j)+ C(n+floor(Mf/2),m+floor(Mf/2))*Ez1(i-n*shiftU,j-m*shiftU);
%                     end
%                 end
%             end
%         end
%     end
% end
 
% figure;
% imagesc(yvec/nm,xvec/nm,abs(totalEx).^2+abs(totalEy).^2+abs(totalEz).^2);
% title(num2str(a/nm));
% xlabel('x position on the lattice (nm)');
% ylabel('y position on the lattice (nm)');
% for n = -10 : 1 : 10
%     for m = -10 : 1 : 10
%         hold on;
%         th = 0:pi/50:2*pi;
%         xunit = a * cos(th)-n*U;
%         yunit = a * sin(th)-m*U;
%         h = plot(xunit, yunit,'Black');
%         set(gca,'Color',[1,1,1]);
%     end
% end
 
save(strcat('neff_supermodes2D_',num2str(wl/nm)),'a_vec','neff_supermode','Mf','II_vec','JJ_vec','KK_vec','beta_vec');
